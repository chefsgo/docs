# http 模块

http 模块提供基本的HTTP功能。采用 Router（路由器） 的设计模式，所有请求基于路由定义，并非传统意义上的 **MVC** 模式，我们认为 **MVC** 会增加开发的复杂性，多了一些没有用的概念。

并且 视图层（View）的必要性不是很大，因为现今大多数项目都是前后端分离的，大多数的后端项目是以接口的方式提供服务，所以我们重点设计了接口这一部分的功能。

不过我们仍然设计了 view（视图模块），并且开发了基于 Golang template 的默认view驱动，应该可以照顾到绝大多数的需要。

## Context 上下文

http 请求的执行线类似于 “洋葱” 一样的设计，每个请求都会有一例会的方法被执行，其中包括拦截器，路由方法，处理器等等。 Context 贯穿整个执行过程，请求和响应都包装在了 Context 上下文中。


## 执行过程

我们将http请求分成了 **3** 个阶段，在 **3** 个阶段中分别处理不同的事情，分别如下：

1. Request - 请求阶段
2. Execute - 执行阶段
3. Response - 响应阶段

### 1. Request - 请求阶段

在收到HTTP请求的一开始，系统会做一些初始化的工作，然后进入 Request - 请求阶段。

在 Request 阶段，系统会先调用 RequestFilter（请求拦截器），然后调用系统内置的一些请求处理的方法，比如 Token处理，Body解析，参数解析等等。

- RequestFilter 请求拦截器
- Token处理
- Body解析
- 参数解析

### 2. Execute - 执行阶段

上一个阶段完成之后，系统会调用 ExecuteFilter（执行拦截器），然后调用 Router（路由器）的 Action方法 或 Actions 方法列表。

- ExecuteFilter 执行拦截器
- Router.Actions 路由方法列表（如果有定义的话）
- Router.Action 路由方法（如果有定义的话）

### 3. Response - 响应阶段

无论 Request请求阶段 或是 Execute阶段 是否执行成功，或是产生了什么错误，最终都会进入到 Response阶段，最终将响应发送给客户端，是在 Response阶段 完成的，`在前面的Request, Execute两个阶段中，都只能设置响应方式和内容，不会真正的把内容发回客户端`。

所以，你在上下文中做的任何操作，都可以在 Filter拦截器 和 Handler处理器 中被修改和更新，这便是 Filter拦截器 和 Handler处理器 的意义所在。


## Driver 驱动化设计 

驱动化的设计，你可以很方便的编写自己的http驱动。默认http驱动基于开源项目 github.com/gorilla/mux ，感谢作者的贡献。

## 多站点支持

http 模块会监听 **1** 个http端口，并且支持多站点，不同站点使用 **域名** 进行绑定，站点需要提前配置。



## Router 路由器

http 的核心就是Router路由器，所有请求都直接进入路由器，包括不存在的页面。

## Filter 拦截器

http 拦截器，类似于其它框架中的 中间件(Middleware)，但是我们做了更深入的设计，将拦截器分为 **3** 个阶段，方便你更精细的处理请求。

## Handler 处理器

http 请求中，会有一些情况需要特殊处理，比较找不到页面（404），程序发生错误，参数解析失败，登录验证失败等等。